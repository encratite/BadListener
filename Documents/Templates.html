<!doctype html>
<html>
	<head>
		<title>Template Language</title>
		<style>
			body {
				font-family: Helvetica, sans-serif;
				font-size: 16px;
			}
			
			p, li {
				line-height: 26px;
			}
			
			a {
			  color: #396cad;
			  text-decoration: none;
			  font-weight: bold;
			}
			
			a:hover {
			  text-decoration: underline;
			}
			
			pre {
				font-size: 14px;
				font-family: Consolas, Courier, monospace;
				color: rgb(245, 245, 245);
				background-color: rgb(245, 245, 245);
				border: 1px solid rgb(216, 216, 216);
				padding: 1em;
				white-space: pre-wrap;
				margin-bottom: 2em;
			}
			
			.container {
				max-width: 850px;
				margin: 2em auto;
			}
			
			.code {
				font-weight: bold;
			}
		</style>
		<script>
			document.addEventListener("DOMContentLoaded", function(event) {
				var elements = document.getElementsByTagName("pre");
				for (var i = 0; i < elements.length; i++) {
					var pre = elements[i];
					var text = pre.innerText;
					text = text.replace(/\[/g, "<");
					text = text.replace(/\]/g, ">");
					pre.innerText = text;
					pre.style.color = "black";
				}
			});
		</script>
	</head>
	<body>
		<div class="container">
			<h1>Introduction</h1>
			<p>
				This is some kind of design document for the HTML template language I intend to develop for my crude C# web framework <a href="https://github.com/epicvrvs/BadListener">BadListener</a>.
				I previously used an open source implementation of Microsoft's ASP.NET Razor engine called <a href="https://github.com/Antaris/RazorEngine">RazorEngine</a>.
				I made it part of a simple MVC-like environment that I deployed on low end Linux servers using <a href="http://www.mono-project.com/">Mono</a> and <a href="https://nginx.org/">nginx</a> (for serving static content).
			</p>
			<p>
				Unfortunately, compiling the templates was enormously slow.
				Individual .cshtml template files would often take 1500-4000 ms to process, which slowed down the startup of the server and also made testing small changes quite cumbersome.
				The engine, much like Microsoft's, generates C# source code from your templates which is then compiled and loaded as dynamic assemblies.
				AppDomains are used to isolate the template code, to protect the process to some extent.
				The slow compilation and my general interest in trying out new technology are the primary reasons I started exploring alternatives such as completely writing the template engine myself.
			</p>
			
			<h1>Goals</h1>
			<ul>
				<li>Compilation should not take more than 50 ms per template file on low end Linux boxes</li>
				<li>Rendering overhead should be negligible (not more than 5 ms)</li>
				<li>Low code complexity</li>
			</ul>
			
			<h1>Outline</h1>
			<ul>
				<li>Generate bytecode using Microsoft's <a href="https://msdn.microsoft.com/en-us/library/system.linq.expressions.expression(v=vs.110).aspx">Expression API</a></li>
				<li>Expressions operate on models (CLR objects) returned by controllers</li>
				<li>Static typing</li>
				<li>Lisp-like prefix notation rather than C#-like infix notation (easier to parse)</li>
				<li>Small number of built-in types</li>
				<li>Small number of operators (no binary operators, no assignment operators)</li>
				<li>Small number of other built-in functions</li>
				<li>No support for common features of high-level languages</li>
				<li>No proper user-defined functions with static type signatures, only primitive macros that generate code</li>
				<li>No first-class functions</li>
				<li>Model type is derived from the controller's signature, not from the template (unlike in ASP.NET MVC)</li>
			</ul>
			
			<h1>Examples</h1>
			
			<h2>Literals and Code Blocks</h2>
			<p>
				Each portion of the template is either a literal that emits HMTL/CSS/JavaScript plain text or a block of code that may alter the flow of execution and is also capable of emitting text.
			</p>
			<p>
				Initially, the parser processes any line in literal mode.
				Each line of text whose first non-whitespace character is an opening bracket causes the parser to switch from literal mode to code mode.
			</p>
			<pre>
[p]Here's some text (this is still a literal).[/p]
(write "[p]This, however, was emitted by a block of code.[/p]")</pre>
			<p>
				<span class="code">write</span> is one of the basic built-in functions to emit text programmatically.
				It is also possible to quickly switch to code mode and call the write function using the <span class="code">@</span> prefix.
				I somewhat copied this feature from Microsoft's Razor engine.
				While this special character is used in CSS and in email addresses, it is sufficiently rare and conveniently placed on most keyboards - which is likely the reason they chose to use it in their .cshtml templates.
			</p>
			<pre>
[p]Hello @Name![/p]</pre>
			<p>
				Whereas the verbose version might look like this:
			</p>
			<pre>
(write (concat "[p]Hello " Name "![/p]"))</pre>
</pre>
			<p>
				<span class="code">concat</span> is a built-in variadic function that concatenates strings.
				Using the plus operator for that purpose would certainly be more convenient and I might implement that in future.
				However, regular Add expressions are incompatible with the C# String class as it lacks the corresponding overload at the CLR level.
			</p>
			<p>
				But wait, there's more!
				I intend to implement another questionable way of quickly switching back and forth between literal mode and code mode:
			</p>
			<pre>
(if false
	([p]Wait, what?[/p]))</pre>
</pre>
			<p>
				The switch from code mode to literal mode is triggered by the sequence of the opening bracket and an opening HTML tag followed by an alphabetic character (to prevent confusion with the less-than operator), while the switch back is triggered by the sequence of a closing HTML tag followed by a closing bracket.
				This is primarily useful for putting literals into if/else/for blocks without breaking the somewhat Lisp-like formatting by forcing users to place their opening brackets at the end of a line of code or the closing brackets on a line of its own.
			</p>
			<p>
				There are more examples in the sections entitled <i>Conditional Statments</i> and <i>Loops</i>.
			</p>
			
			<h2>Models</h2>
			<p>These are the C# classes used in the following examples.</p>
			<pre>
// This is the model returned by the controller
public class Addict
{
	// The name of the user
	public string Name { get; set; }
	
	// The drinks recently consumed by the user
	public List[Drink] Drinks { get; set; }
}

public class Drink
{
	// The name of the drink
	public string Name { get; set; }
	
	// The amount consumed, in millilitres
	public int Amount { get; set; }
}</pre>
		
			<h2>Accessing Properties</h2>
			<p>
				All public properties of the model (<span class="code">Name</span> and <span class="code">Drinks</span>) are exposed as globals.
			</p>
			<pre>
[h1]@Name's Drinks[/h1]
[ul]
	[li]First drink: @(.Name (item Drinks 0))[/li]
	[li]Second drink: @(.Name (item Drinks 1))[/li]
[/ul]</pre>
			<p>
				<span class="code">item</span> is a built-in function that returns the nth item of any enumerable type.
				Lisp nerds will hate me for not using "nth" or "elt" but, well, this is not a dialect of Lisp and it is more consistent with CLR terminology.
			</p>
			<p>
				<span class="code">.Name</span> generates an expression that returns the <span class="code">Name</span> property of its argument.
				Do not mistake it for an implicitly generated accessor - it is just type-agnostic syntactic sugar for the built-in <span class="code">property</span> function:
			</p>
<pre>
[h1]@Name's Drinks[/h1]
[ul]
	[li]First drink: @(property (item Drinks 0) "Name")[/li]
	[li]Second drink: @(property (item Drinks 1) "Name")[/li]
[/ul]</pre>
		
			<h2>Conditional Statements</h2>
			<p>
				This pattern generates an if-then-else expression or an if-then expression, depending on whether the third argument had been specified.
			</p>
			<pre>
(if (]= (length Drinks) 5)
	([p]@Name is likely drunk.[/p])
	([p]@Name is fine.[/p]))

(if (= (length Drinks) 0)
	([p]What a pussy![/p]))</pre>

			<h2>Loops</h2>
			<p>
				Most of the time, I only have use for plain foreach loops.
				You can abuse them to imitate classical C-style for loops, too.
				I might add some kind of while loop in future, though.
			</p>
			<pre>
[ol]
	(foreach drink Drinks
		([li]@(.Amount drink) ml of @(.Name drink)[/li]))
[/ol]
</pre>

			<h2>Macros</h2>
			<p>
				The template language lacks proper functions but it does come with a feature that somewhat resembles C-style pre-processor macros that basically just generate code.
			</p>
			<pre>
(define showDrink (description i)
	([li]@description: @(.Name (item Drinks i))[/li])

[h1]@Name's Drinks[/h1]
[ul]
	(showDrink "First drink" 0)
	(showDrink "Second drink" 1)
[/ul]</pre>
			<p>
				The <span class="code">define</span> statements are really just expanded like this:
			</p>
			<pre>
[h1]@Name's Drinks[/h1]
[ul]
	([li]First drink: @(.Name (item Drinks 0))[/li])
	([li]Second drink: @(.Name (item Drinks 1))[/li])
[/ul]</pre>
			<p>
				This is more convenient as the language is statically typed but lacks type annotations.
				I considered using a C++ template like approach in which one instance of the actual function code would be generated per distinct tuple of template types it was used with in the application.
				It would increase the complexity of the code without having much of a beneficial impact on the performance, though.
			</p>
			
			<h1>Built-In Stuff</h1>
			
			<h2>Types and Constants</h2>
			<p>
				Strings attached. Only one escape sequence is currently supported.
			</p>
			<pre>
"Derp."
"Even more \"derp\"."</pre>
			<p>
				Such integers. Amaze. All Int32. Sorry for that.
			</p>
			<pre>
0
-1
234563645</pre>
			<p>
				Double up! No floats. No ".3" notation supported.
			</p>
			<pre>
8.0
-23.5e88</pre>
			<p>
				True or false? It's all the same to the uncaring universe.
			</p>
			<pre>
false
true</pre>

			<h2>Operators</h2>
			<p>
				Logical operators:
			</p>
			<pre>
(not a)
(and a b)
(or a b)
</pre>
			<p>
				Arithmetic operators:
			</p>
			<pre>
(+ a b)
(- a b)
(* a b)
(/ a b)
(% a b)
</pre>
			<p>
				Comparison operators:
			</p>
			<pre>
(= a b)
(!= a b)
([ a b)
(] a b)
([= a b)
(]= a b)
</pre>

			<h2>Functions</h2>
			<p>
				A conditional statement with or without an else body, depending on the number of arguments.
			</p>
			<pre>
(if condition then)
(if condition then else)</pre>
			<p>
				Iterate over the elements of an IEnumerable, assigning the current value to the iterator.
				Do stuff with the iterator in the body.
			</p>
			<pre>
(foreach iterator enumerable body)</pre>
			<p>
				Returns the Length() of an IEnumerable.
				Might also support arrays in future.
				Don't really have any use for those right now, though.
			</p>
<pre>
(length enumerable)</pre>
			<p>
				Retrieve the nth element of an IEnumerable.
				Might support arrays in future, too.
			</p>
<pre>
(item enumerable n)</pre>
			<p>
				Generate an expression that returns the property of the argument.
				Comes in two flavours: the one with syntactic sugar and the verbose one.
			</p>
			<pre>
(.TheProperty object)
(property object "TheProperty")</pre>
			<p>
				Emit HTML/CSS/JavaScript to the output buffer.
			</p>
			<pre>
(write text)</pre>
			<p>
				Define a C-style macro.
				At compile-time, any use of the macro will be expanded to the body of the macro with the arguments substituted.
				There are no type signatures for the arguments.
				You may abuse a macro to pass any types you wish as long as the code compiles after expansion.
				This language currently lacks proper functions.
			</p>
			<pre>
(define macro (argument_1 ... argument_n) body)
</pre>
		</div>
	</body>
</html>